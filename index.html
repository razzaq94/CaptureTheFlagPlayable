<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Capture the Flag 3D - Playable Ad (DEV)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }
    /* HUD text */
    #ui {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #fff;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
      pointer-events: none;
      text-align: center;
      white-space: nowrap;
      z-index: 5;
    }
    /* Start / end overlays */
    #startOverlay, #endOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0,0,0,0.7);
      color: #fff;
      font-family: system-ui, sans-serif;
      text-align: center;
      z-index: 10;
    }
    #startOverlay button, #endOverlay button {
      margin-top: 16px;
      padding: 10px 24px;
      border: none;
      border-radius: 999px;
      background: #ffcc00;
      color: #000;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    #endOverlay { display: none; }

    /* Simple on-screen arrow that points toward the flag holder */
    #flagArrow {
      position: fixed;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 18px solid #ffcc00; /* triangle pointing up by default */
      transform-origin: 50% 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 6;
      display: none;
    }
  </style>
</head>
<body>
<div id="ui"></div>
<div id="startOverlay">
  <h2>Capture the Flag</h2>
  <p>Steer left / right to chase and steal the flag.</p>
  <p>Hold it longer than enemies in 60 seconds!</p>
  <button id="startBtn">Tap to Play</button>
</div>
<div id="endOverlay">
  <h2 id="endTitle"></h2>
  <p id="endStats"></p>
  <button id="ctaBtn">Play Full Game</button>
</div>
<!-- Arrow that indicates the off-screen flag holder direction -->
<div id="flagArrow"></div>

<!-- Three.js from CDN (for DEV only; later you'll inline this) -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
const GAME_DURATION = 60;
const NUM_ENEMIES = 5;
const WORLD_SIZE = 800 * 3; // Increased by 200% (3x original size)

// Movement / turn speeds (increased by 300% from the original values)
const BASE_SPEED = 60 * 3;
const FLAG_SPEED_MULTIPLIER = 0.8; // 20% slower when holding flag
// Softer turning: reduce from 3x to 1.5x original, and make enemies turn even slower
const TURN_SPEED = Math.PI * 1.5;          // player turn speed
const ENEMY_TURN_SPEED = TURN_SPEED * 0.5; // enemies turn at 50% of player turn speed
const COLLISION_RADIUS = 12;

const ui = document.getElementById("ui");
const startOverlay = document.getElementById("startOverlay");
const startBtn = document.getElementById("startBtn");
const endOverlay = document.getElementById("endOverlay");
const endTitle = document.getElementById("endTitle");
const endStats = document.getElementById("endStats");
const ctaBtn = document.getElementById("ctaBtn");
const flagArrow = document.getElementById("flagArrow");

let gameStarted = false;

// INPUT: left / right steering via arrow keys, touch, or mouse
const input = { left: false, right: false };

// Keyboard controls
window.addEventListener("keydown", e => {
  if (e.code === "ArrowLeft") { input.left = true; e.preventDefault(); }
  if (e.code === "ArrowRight") { input.right = true; e.preventDefault(); }
});
window.addEventListener("keyup", e => {
  if (e.code === "ArrowLeft") input.left = false;
  if (e.code === "ArrowRight") input.right = false;
});

// Touch controls: tap left/right side of screen to steer
function handleTouchStart(e) {
  // Don't interfere with button clicks
  const target = e.target;
  if (target.tagName === "BUTTON" || target.closest("button")) return;
  
  e.preventDefault();
  const touch = e.touches[0] || e.changedTouches[0];
  const screenX = touch.clientX;
  const midX = window.innerWidth / 2;
  
  if (screenX < midX) {
    input.left = true;
    input.right = false;
  } else {
    input.left = false;
    input.right = true;
  }
}

function handleTouchEnd(e) {
  // Don't interfere with button clicks
  const target = e.target;
  if (target.tagName === "BUTTON" || target.closest("button")) return;
  
  e.preventDefault();
  input.left = false;
  input.right = false;
}

// Mouse controls (for desktop testing): click left/right side of screen
function handleMouseDown(e) {
  // Don't interfere with button clicks
  const target = e.target;
  if (target.tagName === "BUTTON" || target.closest("button")) return;
  
  const midX = window.innerWidth / 2;
  
  if (e.clientX < midX) {
    input.left = true;
    input.right = false;
  } else {
    input.left = false;
    input.right = true;
  }
}

function handleMouseUp(e) {
  // Don't interfere with button clicks
  const target = e.target;
  if (target.tagName === "BUTTON" || target.closest("button")) return;
  
  input.left = false;
  input.right = false;
}

// Add touch event listeners
window.addEventListener("touchstart", handleTouchStart, { passive: false });
window.addEventListener("touchend", handleTouchEnd, { passive: false });
window.addEventListener("touchcancel", handleTouchEnd, { passive: false });

// Add mouse event listeners (for desktop testing)
window.addEventListener("mousedown", handleMouseDown);
window.addEventListener("mouseup", handleMouseUp);

// Start button – timer only runs after user interaction (playable requirement)
startBtn.addEventListener("click", () => {
  if (!gameStarted) {
    gameStarted = true;
    startOverlay.style.display = "none";
    lastTime = performance.now();
  }
});

// CTA: open store
ctaBtn.addEventListener("click", () => {
  goToStore();
});

function goToStore() {
  const url = "https://example.com/your-store-url"; // replace with real store URL
  if (window.mraid && mraid.open) {
    mraid.open(url);
  } else {
    window.open(url, "_blank");
  }
}

// THREE.js scene / renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

// Orthographic camera setup (replaces perspective camera)
const frustumSize = 600;
let aspect = window.innerWidth / window.innerHeight;
const camera = new THREE.OrthographicCamera(
  (-frustumSize * aspect) / 2,
  (frustumSize * aspect) / 2,
  frustumSize / 2,
  -frustumSize / 2,
  0.1,
  2000
);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.insertBefore(renderer.domElement, document.body.firstChild);

window.addEventListener("resize", () => {
  aspect = window.innerWidth / window.innerHeight;
  camera.left = (-frustumSize * aspect) / 2;
  camera.right = (frustumSize * aspect) / 2;
  camera.top = frustumSize / 2;
  camera.bottom = -frustumSize / 2;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Lights
const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(200, 300, 100);
scene.add(dirLight);

// Ground plane
const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 20, 20);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

const gridHelper = new THREE.GridHelper(WORLD_SIZE, 20, 0x333333, 0x333333);
scene.add(gridHelper);

// Car class – represents both player and enemies
class Car {
  constructor(color, isPlayer = false, aiBias = 0) {
    const bodyGeo = new THREE.BoxGeometry(16, 8, 32);
    const bodyMat = new THREE.MeshStandardMaterial({ color });
    this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
    scene.add(this.mesh);

    this.isPlayer = isPlayer;
    this.hasFlag = false;
    this.angle = 0;
    this.baseSpeed = BASE_SPEED;
    // AI bias: unique offset angle for each enemy to prevent merging
    this.aiBias = aiBias;

    const flagGeo = new THREE.SphereGeometry(4, 12, 12);
    const flagMat = new THREE.MeshStandardMaterial({ color: 0xffd93d });
    this.flagIndicator = new THREE.Mesh(flagGeo, flagMat);
    this.flagIndicator.position.set(0, 8, 0);
    this.mesh.add(this.flagIndicator);
  }

  getSpeed() {
    return this.baseSpeed * (this.hasFlag ? FLAG_SPEED_MULTIPLIER : 1);
  }

  setPosition(x, z) {
    this.mesh.position.set(x, 4, z);
  }

  // Per-frame update: movement + rotation
  update(dt, world) {
    if (this.isPlayer) {
      if (input.left) this.angle -= TURN_SPEED * dt;
      if (input.right) this.angle += TURN_SPEED * dt;
    } else {
      this.updateAI(dt, world);
    }

    const speed = this.getSpeed();
    this.mesh.position.x += Math.cos(this.angle) * speed * dt;
    this.mesh.position.z += Math.sin(this.angle) * speed * dt;

    this.mesh.position.x = THREE.MathUtils.clamp(
      this.mesh.position.x,
      -WORLD_SIZE / 2,
      WORLD_SIZE / 2
    );
    this.mesh.position.z = THREE.MathUtils.clamp(
      this.mesh.position.z,
      -WORLD_SIZE / 2,
      WORLD_SIZE / 2
    );

    this.mesh.rotation.y = -this.angle + Math.PI / 2;
    this.flagIndicator.visible = this.hasFlag;
  }

  // Simple AI:
  // - If this car has the flag, it runs away from nearest chaser (car without flag)
  // - If it doesn't have the flag, it chases the current flag holder
  // Each enemy has a unique bias angle to prevent them from merging together
  updateAI(dt, world) {
    const flagHolder = world.flagHolder;
    if (!flagHolder) return;

    const myPos = this.mesh.position;
    if (this.hasFlag) {
      // run away from nearest car without flag
      let nearest = null;
      let nearestDist2 = Infinity;
      for (const c of world.cars) {
        if (c === this) continue;
        if (!c.hasFlag) {
          const d2 = myPos.distanceToSquared(c.mesh.position);
          if (d2 < nearestDist2) {
            nearestDist2 = d2;
            nearest = c;
          }
        }
      }
      if (nearest) {
        const dir = new THREE.Vector2(
          myPos.x - nearest.mesh.position.x,
          myPos.z - nearest.mesh.position.z
        ).normalize();
        // Add bias to create variation in escape paths
        const targetAngle = Math.atan2(dir.y, dir.x) + this.aiBias * 0.3;
        // Enemies turn more slowly / imperfectly toward their target
        this.angle = lerpAngle(this.angle, targetAngle, ENEMY_TURN_SPEED * dt);
      }
    } else {
      // chase flag holder with bias to prevent merging
      const dir = new THREE.Vector2(
        flagHolder.mesh.position.x - myPos.x,
        flagHolder.mesh.position.z - myPos.z
      ).normalize();
      // Add unique bias angle to each enemy so they approach from different angles
      // Bias is scaled by distance to make it more pronounced when far away
      const distToFlag = Math.sqrt(
        Math.pow(flagHolder.mesh.position.x - myPos.x, 2) +
        Math.pow(flagHolder.mesh.position.z - myPos.z, 2)
      );
      const biasScale = Math.min(1.0, distToFlag / 300); // More bias when far, less when close
      const targetAngle = Math.atan2(dir.y, dir.x) + this.aiBias * biasScale * 0.4;
      // Enemies turn more slowly / imperfectly toward their target
      this.angle = lerpAngle(this.angle, targetAngle, ENEMY_TURN_SPEED * dt);
    }
  }
}

function lerpAngle(a, b, maxDelta) {
  let diff = ((b - a + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
  diff = THREE.MathUtils.clamp(diff, -maxDelta, maxDelta);
  return a + diff;
}

// World state
const world = {
  cars: [],
  flagHolder: null,
  time: 0,
  finished: false,
  playerHoldTime: 0,
  enemiesHoldTime: 0
};

const player = new Car(0x3ec1ff, true);
player.setPosition(0, 0);
world.cars.push(player);

// Create enemies with unique AI bias angles to prevent merging
for (let i = 0; i < NUM_ENEMIES; i++) {
  const e = new Car(0xff5c5c, false, (i / NUM_ENEMIES) * Math.PI * 2);
  const ang = (i / NUM_ENEMIES) * Math.PI * 2;
  const r = 200;
  e.setPosition(Math.cos(ang) * r, Math.sin(ang) * r);
  e.angle = ang + Math.PI;
  world.cars.push(e);
}

giveFlagToRandomCar();

// Flag ownership: give the flag to a random car at start
function giveFlagToRandomCar() {
  world.cars.forEach(c => c.hasFlag = false);
  const idx = Math.floor(Math.random() * world.cars.length);
  const c = world.cars[idx];
  c.hasFlag = true;
  world.flagHolder = c;
}

// Camera follow – isometric style, always looking at the player
function updateCamera() {
  const p = player.mesh.position;
  // Zoomed out by 100% (distance & height doubled from original values)
  const dist = 240;
  const height = 240;

  camera.position.set(p.x + dist, p.y + height, p.z + dist);
  camera.lookAt(p.x, p.y, p.z);
}

// Collision & flag transfer – simple sphere collision between cars
function updateCollisions() {
  for (let i = 0; i < world.cars.length; i++) {
    for (let j = i + 1; j < world.cars.length; j++) {
      const a = world.cars[i];
      const b = world.cars[j];
      const d2 = a.mesh.position.distanceToSquared(b.mesh.position);
      if (d2 < COLLISION_RADIUS * COLLISION_RADIUS) {
        if (a.hasFlag && !b.hasFlag) {
          a.hasFlag = false;
          b.hasFlag = true;
          world.flagHolder = b;
        } else if (!a.hasFlag && b.hasFlag) {
          b.hasFlag = false;
          a.hasFlag = true;
          world.flagHolder = a;
        }
      }
    }
  }
}

// HUD: timer + hold times + simple result hint when finished
function updateUI() {
  const remaining = Math.max(0, GAME_DURATION - world.time);
  let result = "";
  if (world.finished) {
    if (world.playerHoldTime > world.enemiesHoldTime) result = " | You Win!";
    else if (world.playerHoldTime < world.enemiesHoldTime) result = " | You Lose!";
    else result = " | Draw!";
  }
  ui.textContent =
    `Time: ${remaining.toFixed(1)}s | Your Hold: ${world.playerHoldTime.toFixed(1)}s | Enemies: ${world.enemiesHoldTime.toFixed(1)}s${result}`;
}

// End screen with summary and CTA
function showEndOverlay() {
  const p = world.playerHoldTime.toFixed(1);
  const e = world.enemiesHoldTime.toFixed(1);

  let title = "Draw!";
  if (world.playerHoldTime > world.enemiesHoldTime) title = "You Win!";
  else if (world.playerHoldTime < world.enemiesHoldTime) title = "You Lose!";

  endTitle.textContent = title;
  endStats.textContent = `You held the flag ${p}s vs ${e}s.`;
  endOverlay.style.display = "flex";
}

// MAIN LOOP – updates game state, camera, UI and renders the frame
let lastTime = performance.now();

function loop(now) {
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  if (gameStarted && !world.finished) {
    world.time += dt;
    if (world.time >= GAME_DURATION) {
      world.time = GAME_DURATION;
      world.finished = true;
      showEndOverlay();
    }

    world.cars.forEach(c => c.update(dt, world));
    updateCollisions();

    if (world.flagHolder) {
      if (world.flagHolder.isPlayer) world.playerHoldTime += dt;
      else world.enemiesHoldTime += dt;
    }
  }

  updateCamera();
  updateUI();
  updateFlagArrow();

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Off-screen flag arrow logic:
// Shows an arrow above the player that points toward the flag holder
function updateFlagArrow() {
  // No arrow if no flag holder or the player currently holds the flag
  if (!world.flagHolder || world.flagHolder === player) {
    flagArrow.style.display = "none";
    return;
  }

  const flagPos = world.flagHolder.mesh.position.clone();
  const playerPos = player.mesh.position.clone();

  // Project positions to NDC (Normalized Device Coordinates)
  const flagNDC = flagPos.project(camera);
  const playerNDC = playerPos.project(camera);

  // Check if flag holder is on-screen
  const flagOnScreen =
    flagNDC.x >= -1 && flagNDC.x <= 1 &&
    flagNDC.y >= -1 && flagNDC.y <= 1 &&
    flagNDC.z >= -1 && flagNDC.z <= 1;

  if (flagOnScreen) {
    flagArrow.style.display = "none";
    return;
  }

  // Convert NDC to screen-space coordinates
  const px = (playerNDC.x * 0.5 + 0.5) * window.innerWidth;
  const py = (-playerNDC.y * 0.5 + 0.5) * window.innerHeight;
  const fx = (flagNDC.x * 0.5 + 0.5) * window.innerWidth;
  const fy = (-flagNDC.y * 0.5 + 0.5) * window.innerHeight;

  const dx = fx - px;
  const dy = fy - py;

  // If the projected direction is degenerate, hide arrow
  if (dx === 0 && dy === 0) {
    flagArrow.style.display = "none";
    return;
  }

  const angle = Math.atan2(dy, dx);

  // Place arrow slightly away from the player in the direction of the flag
  const offset = 40;
  const margin = 16;
  let ax = px + Math.cos(angle) * offset;
  let ay = py + Math.sin(angle) * offset;

  // Clamp arrow to stay within the viewport margins
  ax = Math.max(margin, Math.min(window.innerWidth - margin, ax));
  ay = Math.max(margin, Math.min(window.innerHeight - margin, ay));

  flagArrow.style.display = "block";
  flagArrow.style.left = ax + "px";
  flagArrow.style.top = ay + "px";
  // Our CSS triangle points "up" (toward -Y screen), so rotate accordingly
  const deg = angle * 180 / Math.PI + 90;
  flagArrow.style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
}
</script>
</body>
</html>

